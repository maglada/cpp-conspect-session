# Повний конспект з C++

## 1. Базові елементи мови C++

### 1.1 Лексеми
- Одиниця тексту програми, яка має певний сенс для компілятора і не може бути розбита надалі
- Види лексем:
  - Ключові слова
  - Ідентифікатори
  - Константи
  - Знаки операцій
  - Розділювачі

### 1.2 Ідентифікатори
- Довільне ім'я, що визначається користувачем
- Вимоги:
  - Можуть містити букви A-Z, a-z, цифри 0-9, знак підкреслення (_)
  - Повинні починатися з літери або знака підкреслення
  - Є чутливими до регістру
  - Не можуть співпадати з ключовими словами

### 1.3 Ключові слова
- Зарезервовані слова мови: auto, for, int, if, else, static, float, while тощо
- Мають спеціальне значення для компілятора
- Не можуть використовуватися як звичайні ідентифікатори

### 1.4 Типи даних
- Визначають множину значень і операцій над ними
- Основні цілі типи:
  - char
  - int
  - short int
  - long int
  - unsigned модифікації вищевказаних типів
- Типи з плаваючою крапкою:
  - float
  - double
  - long double

### 1.5 Константи
1. Цілі константи:
   - Десяткові: 123 (не починаються з 0)
   - Вісімкові: починаються з 0 (0123)
   - Шістнадцяткові: починаються з 0x або 0X (0x123)

2. Константи з плаваючою крапкою:
   - З фіксованою крапкою: 3.14, 0.123
   - З плаваючою крапкою: 1.23e-4, 1.23E+4

3. Символьні константи:
   - Один символ в апострофах: 'A', '1'
   - ESCAPE-послідовності: '\n', '\t', '\0'

4. Рядкові константи (літерали):
   - Послідовність символів у подвійних лапках: "Hello"

5. Способи оголошення:
   - Типізовані: const int MAX = 100;
   - Нетипізовані: #define MAX 100

### 1.6 Коментарі
- Однорядкові: // текст коментаря
- Багаторядкові: /* текст коментаря */

### 1.7 Директиви препроцесора
- #include - підключення бібліотечних файлів
- #define - створення макросів та нетипізованих констант
- #line - зміна номера рядка
- #using - використання зборок .NET

## 2. Масиви

### 2.1 Визначення
Масив - впорядкована сукупність елементів одного типу

### 2.2 Види масивів
- За розміром:
  - Фіксованої довжини (статичні) - розмір відомий при компіляції
  - Динамічні - розмір визначається під час виконання
- За розмірністю:
  - Одновимірні
  - Двовимірні

### 2.3 Одновимірні масиви
- Оголошення:
```cpp
int arr[5];                // без ініціалізації
int arr[] = {1,2,3,4,5};  // з ініціалізацією
int arr[5] = {1,2,3,4,5}; // з явним розміром
const int n = 5;          // з константою
int arr[n];              
```
- Характеристики:
  - Елементи розташовані послідовно в пам'яті
  - Індексація починається з 0
  - Доступ до елементів: arr[індекс]

### 2.4 Двовимірні масиви
- Оголошення:
```cpp
int arr[3][4];                    // без ініціалізації
int arr[][2] = {{1,2},{3,4}};    // з частковою розмірністю
int arr[2][2] = {1,2,3,4};       // з ініціалізацією
const int n = 3;                  // з константою
int arr[n][n];
```
- Особливості:
  - Представляють таблицю елементів
  - Доступ до елементів: arr[рядок][стовпець]

### 2.5 Робота з областями двовимірного масиву
- Головна діагональ: i == j
- Побічна діагональ: i + j == n-1
- Вище головної діагоналі: i < j
- Нижче головної діагоналі: i > j
- Вище побічної діагоналі: i + j < n-1
- Нижче побічної діагоналі: i + j > n-1

## 3. Оператори та вирази

### 3.1 Базові поняття
- Вираз - основний засіб обчислень, що складається з операторів і операндів
- Операнд - константа, літерал, ідентифікатор або вираз, над яким виконується операція
- Оператор - елемент, що визначає дію над операндами
- Асоціативність - властивість, що визначає порядок виконання операторів з однаковим пріоритетом

### 3.2 Види операторів
1. Арифметичні:
   - Мультиплікативні: *, /, %
   - Адитивні: +, -
   
2. Операції відношення: ==, !=, <, >, <=, >=

3. Логічні операції: 
   - &&, ||, !

4. Побітові операції:
   - &, |, ^, ~ 

5. Операції присвоєння:
   - Просте: =
   - Складене: +=, -=, *=, /=, >>=, <<=

6. Інкремент/декремент:
   - Префіксний: ++a, --a
   - Постфіксний: a++, a--

### 3.3 Приклади обчислень
```cpp
int a = 12;
b = ++a;    // b = 13, a = 13
b = a++;    // b = 12, a = 13
a += 2;     // a = a + 2
a *= 2;     // a = a * 2
```

## 4. Керуючі конструкції

### 4.1 Умовний оператор
```cpp
if (умова) оператор1;
[else оператор2;]
```

### 4.2 Оператор вибору
```cpp
switch (вираз) {
    case константа1: оператори1; break;
    case константа2: оператори2; break;
    default: оператори;
}
```

### 4.3 Цикли
1. З передумовою:
```cpp
while (умова) {
    тіло циклу;
}
```

2. З постумовою:
```cpp
do {
    тіло циклу;
} while (умова);
```

3. З параметром:
```cpp
for (ініціалізація; умова; зміна) {
    тіло циклу;
}
```

4. Цикл по діапазону:
```cpp
for (тип ідентифікатор : контейнер) {
    тіло циклу;
}
```

### 4.4 Оператори переривання
- break - перериває виконання найближчого switch або циклу
- continue - пропускає решту ітерації циклу
- return - повертає значення з функції

## 5. Області видимості

### 5.1 Блокова область видимості
```cpp
int a = 2;      // глобальна змінна
{
    int a = -7; // локальна змінна
    // тут a = -7
}
// тут a = 2
```

### 5.2 Порожній оператор
- Складається лише з крапки з комою
- Не виконує жодних дій

### 5.3 Складений оператор (блок)
- Послідовність операторів у фігурних дужках
- Створює нову область видимості

## 6. Показники та формати чисел

### 6.1 Числа з плаваючою крапкою
- Формат: mantissa E exponent
- Приклади:
  - 4.8e00 = 4.8
  - 9.5e+01 = 95
  - 6.7e-02 = 0.067

### 6.2 Побітові операції
- Приклади обчислень:
```cpp
0b00110111 & 0b00101101 = 0b00100101
0b00110111 | 0b00101101 = 0b00111111
0b00110111 ^ 0b00101101 = 0b00011010
```

### 6.3 Логічні вирази
- Приклади:
```cpp
(4>=3) && (5!=6)     // результат: 1 (true)
!((3>=4) || (5!=6))  // результат: 0 (false)
```
# Повний конспект з C++

[Previous sections 1-6 remain the same...]

## 7. Функції

### 7.1 Визначення та оголошення функцій
- Функція - іменований блок коду, який можна викликати з різних місць програми
- Синтаксис:
```cpp
тип_повернення ім'я_функції(параметри) {
    тіло функції;
    return значення;
}
```
- Прототип функції (оголошення):
```cpp
тип_повернення ім'я_функції(параметри);
```

### 7.2 Параметри функцій
- За значенням:
```cpp
void func(int x) { x++; }  // зміни не впливають на оригінал
```
- За посиланням:
```cpp
void func(int& x) { x++; }  // зміни впливають на оригінал
```
- За константним посиланням:
```cpp
void func(const int& x) { /* не можна змінювати x */ }
```

### 7.3 Перевантаження функцій
- Можливість створювати функції з однаковим ім'ям, але різними параметрами
```cpp
int sum(int a, int b) { return a + b; }
double sum(double a, double b) { return a + b; }
```

### 7.4 Inline функції
- Рекомендація компілятору вставити код функції безпосередньо в місце виклику
```cpp
inline int max(int a, int b) {
    return (a > b) ? a : b;
}
```

### 7.5 Значення параметрів за замовчуванням
```cpp
void print(int x, string msg = "Value: ") {
    cout << msg << x << endl;
}
```

## 8. Вказівники

### 8.1 Основні поняття
- Вказівник - змінна, яка містить адресу іншої змінної
- Оголошення:
```cpp
тип* ім'я_вказівника;
int* ptr;  // вказівник на int
```

### 8.2 Операції з вказівниками
- & - отримання адреси змінної
- * - розіменування вказівника
```cpp
int x = 10;
int* ptr = &x;    // ptr містить адресу x
*ptr = 20;        // змінюємо значення x через вказівник
```

### 8.3 Арифметика вказівників
- Додавання/віднімання цілих чисел
- Різниця між вказівниками
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* p = arr;     // p вказує на перший елемент
p++;              // p вказує на другий елемент
*(p + 2);         // доступ до четвертого елемента
```

### 8.4 Вказівники та масиви
- Масив автоматично перетворюється на вказівник на перший елемент
- Індексація масиву через вказівник:
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* p = arr;
// Еквівалентні записи:
arr[2] == *(arr + 2) == *(p + 2) == p[2]
```

### 8.5 Вказівники на функції
- Дозволяють зберігати адреси функцій
```cpp
int (*func_ptr)(int, int);  // оголошення вказівника на функцію
int sum(int a, int b) { return a + b; }
func_ptr = sum;             // присвоєння адреси функції
int result = func_ptr(5, 3);// виклик через вказівник
```

### 8.6 Константні вказівники
- const int* ptr - вказівник на константу
- int* const ptr - константний вказівник
- const int* const ptr - константний вказівник на константу

### 8.7 nullptr
- Спеціальне значення для позначення недійсного вказівника
```cpp
int* ptr = nullptr;
if (ptr == nullptr) {
    // обробка випадку недійсного вказівника
}
```

### 8.8 Динамічна пам'ять
- new - виділення пам'яті
- delete - звільнення пам'яті
```cpp
int* p = new int;      // виділення пам'яті для одного int
int* arr = new int[5]; // виділення пам'яті для масиву
delete p;              // звільнення пам'яті
delete[] arr;          // звільнення пам'яті масиву
```
## 9. Структури та об'єднання

### 9.1 Структури (struct)
- Користувацький тип даних, що об'єднує різні типи даних
- Оголошення:
```cpp
struct Person {
    string name;
    int age;
    double height;
    
    // Конструктор
    Person(string n = "", int a = 0, double h = 0.0) 
        : name(n), age(a), height(h) {}
};
```
- Використання:
```cpp
Person p1;                           // створення об'єкта
Person p2 = {"John", 25, 1.75};     // ініціалізація
Person p3{"Alice", 30, 1.65};       // uniform initialization
p1.name = "Bob";                    // доступ до полів
```

### 9.2 Об'єднання (union)
- Тип даних, де всі члени використовують одну область пам'яті
- Розмір об'єднання визначається найбільшим членом
```cpp
union Data {
    int i;
    float f;
    char str[20];
};
```
- Використання:
```cpp
Data data;
data.i = 10;    // тепер можна використовувати тільки data.i
data.f = 3.14;  // попереднє значення data.i втрачено
```

## 10. Робота з файлами

### 10.1 Потоки введення-виведення
- ifstream - для читання з файлу
- ofstream - для запису у файл
- fstream - для читання і запису

### 10.2 Відкриття та закриття файлів
```cpp
#include <fstream>

ofstream outFile("output.txt");              // створення/відкриття для запису
ifstream inFile("input.txt");                // відкриття для читання
fstream file("data.txt", ios::in | ios::out);// відкриття для читання і запису

// Перевірка відкриття
if (!inFile.is_open()) {
    cerr << "Помилка відкриття файлу!" << endl;
    return 1;
}

// Закриття файлу
inFile.close();
```

### 10.3 Операції з файлами
```cpp
// Запис у файл
ofstream outFile("output.txt");
outFile << "Hello" << endl;
outFile << 42 << endl;

// Читання з файлу
ifstream inFile("input.txt");
string line;
while (getline(inFile, line)) {
    cout << line << endl;
}

// Читання форматованих даних
int num;
string str;
inFile >> num >> str;

// Позиціонування в файлі
file.seekg(0, ios::beg);  // на початок файлу
file.seekg(0, ios::end);  // в кінець файлу
file.seekg(10, ios::cur); // відносне позиціонування
```

## 11. Перевантаження операторів

### 11.1 Синтаксис перевантаження
```cpp
class Complex {
    double re, im;
public:
    // Перевантаження оператора додавання
    Complex operator+(const Complex& other) const {
        return Complex(re + other.re, im + other.im);
    }
    
    // Перевантаження оператора множення на число
    Complex operator*(double value) const {
        return Complex(re * value, im * value);
    }
    
    // Перевантаження оператора виведення
    friend ostream& operator<<(ostream& os, const Complex& c) {
        os << c.re << "+" << c.im << "i";
        return os;
    }
};
```

### 11.2 Правила перевантаження
- Не можна змінювати пріоритет операторів
- Не можна перевантажувати: ., ::, ?:, sizeof
- Не можна створювати нові оператори
- Принаймні один операнд має бути користувацького типу

### 11.3 Часто перевантажувані оператори
- Арифметичні: +, -, *, /
- Порівняння: ==, !=, <, >, <=, >=
- Присвоєння: =
- Індексація: []
- Виклик функції: ()
- Перетворення типів: operator type()
- Введення/виведення: >>, <<

### 11.4 Приклад повного перевантаження
```cpp
class Vector {
    int* arr;
    int size;
public:
    // Конструктори
    Vector(int s = 0) : size(s) {
        arr = new int[size];
    }
    
    // Перевантаження оператора індексації
    int& operator[](int index) {
        return arr[index];
    }
    
    // Перевантаження присвоєння
    Vector& operator=(const Vector& other) {
        if (this != &other) {
            delete[] arr;
            size = other.size;
            arr = new int[size];
            for(int i = 0; i < size; i++)
                arr[i] = other.arr[i];
        }
        return *this;
    }
    
    // Деструктор
    ~Vector() {
        delete[] arr;
    }
};
```
## 12. Вектори

### 12.1 Основні поняття
- vector - динамічний масив, що автоматично змінює розмір
- Знаходиться в бібліотеці <vector>
- Зберігає елементи послідовно в пам'яті
```cpp
#include <vector>
vector<тип> назва;  // загальний синтаксис
vector<int> v1;     // пустий вектор
vector<int> v2(5);  // вектор з 5 елементів зі значенням 0
vector<int> v3(3, 7);// вектор з 3 елементів зі значенням 7
vector<int> v4{1, 2, 3, 4, 5};  // ініціалізація значеннями
```

### 12.2 Основні методи
```cpp
vector<int> vec;
vec.push_back(10);     // додати елемент в кінець
vec.pop_back();        // видалити останній елемент
vec.size();           // отримати розмір
vec.empty();          // перевірка на пустоту
vec.clear();          // очистити вектор
vec.front();          // перший елемент
vec.back();           // останній елемент
vec.reserve(100);     // зарезервувати пам'ять
vec.resize(5);        // змінити розмір
vec.capacity();       // отримати ємність
```

### 12.3 Доступ до елементів
```cpp
vector<int> vec{1, 2, 3, 4, 5};
vec[0];               // через оператор індексації (без перевірки)
vec.at(0);            // через метод at() (з перевіркою)

// Ітерація по вектору
for(int i = 0; i < vec.size(); i++) {
    cout << vec[i] << " ";
}

// Ітерація через ітератори
for(auto it = vec.begin(); it != vec.end(); ++it) {
    cout << *it << " ";
}

// Range-based for
for(const auto& element : vec) {
    cout << element << " ";
}
```

### 12.4 Модифікація вектора
```cpp
vector<int> vec{1, 2, 3};

// Вставка елементів
vec.insert(vec.begin(), 0);     // вставка на початок
vec.insert(vec.begin() + 2, 5); // вставка в середину

// Видалення елементів
vec.erase(vec.begin());         // видалення першого елемента
vec.erase(vec.begin(), vec.begin() + 2); // видалення діапазону

// Зміна розміру
vec.resize(10);        // збільшення розміру (нові елементи = 0)
vec.resize(2);         // зменшення розміру (зайві елементи видаляються)
```

### 12.5 Алгоритми з векторами
```cpp
#include <algorithm>
vector<int> vec{3, 1, 4, 1, 5, 9, 2, 6};

// Сортування
sort(vec.begin(), vec.end());               // за зростанням
sort(vec.rbegin(), vec.rend());            // за спаданням

// Пошук
auto it = find(vec.begin(), vec.end(), 5);  // пошук елемента
auto it2 = lower_bound(vec.begin(), vec.end(), 4); // бінарний пошук

// Підрахунок
int count = count_if(vec.begin(), vec.end(), 
    [](int x) { return x > 5; });           // кількість елементів > 5

// Перетворення
transform(vec.begin(), vec.end(), vec.begin(),
    [](int x) { return x * 2; });           // множення всіх елементів на 2
```

### 12.6 Двовимірні вектори
```cpp
// Створення
vector<vector<int>> matrix(3, vector<int>(4, 0));  // 3x4 матриця з нулів

// Доступ до елементів
matrix[0][0] = 1;  // зміна елемента
int val = matrix[1][2];  // читання елемента

// Додавання рядка
matrix.push_back(vector<int>(4, 0));

// Ітерація
for(const auto& row : matrix) {
    for(const auto& elem : row) {
        cout << elem << " ";
    }
    cout << endl;
}
```

### 12.7 Приклади використання
```cpp
// Видалення дублікатів
vector<int> vec{1, 2, 2, 3, 3, 3, 4, 5, 5};
sort(vec.begin(), vec.end());
vec.erase(unique(vec.begin(), vec.end()), vec.end());

// Об'єднання векторів
vector<int> v1{1, 2, 3};
vector<int> v2{4, 5, 6};
v1.insert(v1.end(), v2.begin(), v2.end());

// Реверс вектора
reverse(vec.begin(), vec.end());

// Знаходження мінімального/максимального елемента
auto min_it = min_element(vec.begin(), vec.end());
auto max_it = max_element(vec.begin(), vec.end());
```
